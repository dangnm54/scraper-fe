Clear data flow: Props down, events up


_____min-h-0 & min-w-0
- min-h-0 / min-w-0 only apply to current component if 
- all of its parent chain allow themselves to shrink (usually defualt is min-0-auto -> expand to show all content)



_____truncate
- truncate only works with
    - want-truncated item -> has truncate, max-w/h-full 
    - parent has overflow-hidden




_____full & max-full

h-full -> Make my height exactly 100% of my parent’s height

max-h-full -> My max height cannot more than 100% of my parent’s height, but I can be smaller if my content is smaller or if another height constraint applies.

Can max-h of child ever exceed the parent if you use h-full?
    - No <- if parent has a fixed or constrained height, h-full never make child exceed parent.
    - Yes <- if parent’s height is not set (or is auto), then h-full on child won’t have any effect, and child can grow as large as its content.

However, if you use only max-h-full (without h-full) -> child will only grow up to the parent’s height, but not necessarily fill it.




____flex-1 & size-full
- flex-1
    - flexible growth in a flex container
    - fill space in main axis (of flex direction)
- size-full 
    - explicitly setting width and height to 100%. (only works if parent has explicit size)
    - try to fill all axis

- when use both -> Fills all space in both axes	




____overflow area
- overflow: auto -> scrollable area includes element’s padding.
- padding is part of area that can be scrolled







____________ useRef __________________________________________________________________________________


function SSELog() {
    const [logs, setLogs] = useState([])
    const eventSourceRef = useRef(null)
    const logContainerRef = useRef(null)

    // useRef
        // -> create 'ref object' that is stable across render
            // whenever the component re-render
            // the same ref object is return by useRef instead of creating a entirely new object from scratch
            // eg for 'stable' meaning: 
                // if later eventSourceRef change to diff value (eg: '2' instead of 'null') 
                // when the component (SSELog) re-render
                // the line 'const eventSourceRef = useRef(null)' runs again
                // but React recognized this eventSourcRef is already exist
                // React will return the same ref object ( {current: 2} )
        // - access value of 'ref object'
            // myRef.current -> access current value of myRef (DOM element is also a value)
            // use ref={} in JSX component -> hold DOM element as value
        // - store mutable value that don't trigger re-render
            // - store value that can change
            // when .current value change -> don't trigger re-render -> UI won't change



    useEffect( () => {

        // create EventSource object (built-in browser API) -> allow FE receive SSE from BE
            // similar to event_generator() in BE -> goal is send data
            // EventSource in FE -> receive and parse data
            // goal of this ref (eventSourceRef) is hold EventSource object
            // 'new' -> create new EventSource object (new instance)
        eventSourceRef.current = new EventSource('http://127.0.0.1:8000/sse/logs')

        // event listener -> trigger when connection successfully open
        eventSourceRef.current.onopen = () => {
            console.log('SSE connection opened')
            setLogs(prev => [...prev, '--- SSE Connection Opened ---'])
        }

        // event listener -> trigger everytime BE send new message
            // 'event' object is provided by the EventSource API
        eventSourceRef.current.onmessage = (event) => {

            // event.data contains message from BE
            console.log('Received SSE event:', event)
            console.log('Received SSE message:', event.data)
            
            // prev -> current state of logs before this update
                // [...prev, event.data] -> create new array
                // -> so react can detect state change and re-render
            setLogs(prev => [...prev, event.data])
        }

        // event listener -> trigger when there's error with SSE connection
        eventSourceRef.current.onerror = (error) => {
            console.error('SSE error:', error)
            eventSourceRef.current.close()
            setLogs(prev => [...prev, `--- SSE Error: ${error.message || 'Unknown error'} ---`])
            setLogs(prev => [...prev, `--- SSE Connection Closed ---`])
        }

        // clean up fx
            // definition: a fx that is returned from useEffect
            // clean-up fx runs in 2 case:
                // before the effect runs again <- based on dependencies
                // when component (SSELog) unmounted (removed from DOM) <- eg: switching pages
        return () => {
            if (eventSourceRef.current && eventSourceRef.current.readyState != EventSource.CLOSED) {
                eventSourceRef.current.close()
                console.log('SSE connection closed on component unmount')
            }
        }

    
    }, [])      // [] -> only run once when component first mount (appear on screen)


    useEffect( () => {
        // check if logContainerRef.current refer to any HTML element -> prevent error if component isn't appear in first render in DOM
            // logContainerRef.current -> actual HTML div that marked with ref={logContainerRef}
            // .scrollHeight -> DOM property to tell total height of content in <div>, including content not currently visible due to scrolling
            // .scrollTop -> DOM property to force scrollbar to very bottom
        if (logContainerRef.current) {
            logContainerRef.current.scrollTop = logContainerRef.scrollHeight
        }
    }, [logs])



    return (
        <div id='sse-log-main' className="min-h-0 min-w-0 h-full w-3/5 overflow-hidden border-2 border-gray-300 rounded-lg flex flex-col">
            
            <div id='log-header' className="h-fit w-full p-5 border-b-2 flex flex-row items-center justify-start gap-3"> 
                <MonitorCog className="size-5"/>
                <h2 className="text-lg font-medium text-gray-800">Server Logs</h2>
            </div>

            <pre 
                id="log-content"
                // allow direct access and interact with this <DOM element>
                ref={logContainerRef} 
                className="min-w-0 min-h-0 flex-1 size-full overflow-y-auto p-5 text-sm bg-gray-100 text-gray-800 whitespace-pre-wrap break-words scrollbar scrollbar-thumb-gray-300 scrollbar-track-white"
            >
                {logs.map( (log, index) => {
                    <p key={index}>{log}</p>
                })}
            </pre>

        </div>

    )
}

export default SSELog









____________ api client __________________________________________________________________________________


// async function -> always return a Promise
export async function apiClient<T>(api_endpoint: string, api_options: api_client_options = {}): Promise<API_Result<T>> {

    // get method and body from options -> crt 2 variables
        // default method is GET
    const { method = 'GET', body } = api_options


    // create headers object
        // 'content-type': 'application/json' -> tell BE that request's body is JSON.
        // ...options.header -> add additional headers from options if any
    const headers = new Headers({
        'Content-Type': 'application/json',
        ...api_options.header,
    })


    // 'fetch' has 2 arguments: 'url' (required) and 'options' (optional)
        // if options is used -> must be RequestInit type
        // RequestInit -> define all possible options can pass into 'fetch'         
        // not all HTTP requests are allowed to have body (e.g. 'GET' don't have body)
    const options: RequestInit = {
        method: method,
        headers: headers,
        body: body ? JSON.stringify(body) : undefined,
    }

    // 3 fundamental error to handle
        // 1/ Network error: FE request never reach BE | occur in 'fetch' block and always have TypeError
        // 2/ HTTP (server) error: BE crash while handling request -> response.json() will failed with syntax error
        // 3/ Application (BE) error: BE finish handling request, return un-desired result but correct type 
        // 4/ Data contract error: BE finish handling request, return wrong data type


    // in this case | for BE response, if content.success is false 
        // -> status_code always 4xx or 5xx
        // -> data always null


    try {
        const response = await fetch(`${api_base_url}${api_endpoint}`, options)

        let content: API_Response<T>

        try {
            content = await response.json()
        } catch (jsonError) {
            // HTTP (server) error
            throw new Error(`HTTP error | BE crash while handling request: ${jsonError}`)
        }

        if (typeof content.success !== 'boolean') {
            // data contract error
            throw new Error(`Data contract error | BE return wrong data type`)
        }

        if (content.success) {
            return {message: content.message, data: content.data}
        }
        else {
            // Application (BE) error
            throw new Error(`Application error | BE return correct-typed but un-desired data: ${content.message}`)
        }


    // When write catch (error) -> TypeScript treats error as unknown
    } catch (error: Error | unknown) {
        // Network error
        if (error instanceof Error && error.message === 'Failed to fetch') {
            return {data: null, message: `Network error | Cannot connect to BE`}
        }

        // other error
        return {
            data: null,
            message: error instanceof Error ? error.message : 'Unknown error'
        }
    }
}



____________ blob for downloadable object __________________________________________________________________________________


export default function DataPage(props: DataPage_props) {

    // useEffect( () => {
    //     console.log("[DataPage] Global selected file:", props.app_selectedFile)
    // }, [props.app_selectedFile])

    const downloadFile = async () => {
        `
        - received file data from BE
        - create an file-like object in browser's temporary memory space
        - create temporary download link (point to the file-like object's address in browser memory)
        - click the link to download file
        - clean up temporary resource
        `

        if (!props.app_selectedFile) { return }

        try {
            // in this app
                // if success -> always return stream
                // if fail -> always return JSON
            const response: Response = await fetch(`http://127.0.0.1:8000/api/data/file-download/${props.app_selectedFile.id}`)

            const content_type: string = response.headers.get('content-type') || ''

            if (content_type.includes('text/csv')) {
                
                // using received data, create a blob object in browser's temporary memory space
                    // blob (binary large object) is file-like object of immutable data
                const blob = await response.blob()

                // create DOMString (piece of text) of a URL pointing to blob's address in browser's memory space            
                const url = window.URL.createObjectURL(blob)

                // create <a> element 
                const a_element = document.createElement('a')

                a_element.href = url

                // when element has 'download' attribute, browser treat: 
                    // 'href' as download link
                    // 'file_name' as name for downloadble file
                a_element.setAttribute('download', props.app_selectedFile?.file_name || '')

                // add <a> to <body>
                document.body.appendChild(a_element)

                // click the hidden <a> -> trigger download
                a_element.click()

                // after download, the temporary <a> is removed to clean up DOM
                a_element.remove()

                // release temporary URL created earlier -> free up memory
                window.URL.revokeObjectURL(url)

            } else {
                let error_message = 'Download failed'
                try {
                    const error_content = await response.json()
                    error_message = error_content || error_message
                } catch (jsonError) {
                    console.error({message: "Data contract error | BE return wrong data type"})
                }
                console.error(error_message)
            }

        } catch (error: Error | unknown) {
            if (error instanceof Error && error.message === 'Failed to fetch') {
                return {data: null, message: `Network error | Cannot connect to BE`}
            }
    
            // other error
            return {
                message: error instanceof Error ? error.message : 'Unknown error',
                data: null
            }
        }    
    }
